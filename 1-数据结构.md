# 数据结构  

## ST表  

## 二维哈希  
```cpp
ull hs[109][109], pw1[10009], pw2[100009];
ull gethash(int lx, int ly, int rx, int ry) {
	ull hs1 = hs[lx][ly] - pw2[ry - ly + 1] * hs[lx][ry + 1];
	ull hs2 = hs[rx + 1][ly] - pw2[ry - ly + 1] * hs[rx + 1][ry + 1];
	return hs1 - pw1[rx - lx + 1] * hs2;
}
pw1[0] = pw2[0] = 1;
for(int i = 1; i <= 1000; i++) pw1[i] = pw1[i - 1] * 19260817;
for(int i = 1; i <= 1000; i++) pw2[i] = pw2[i - 1] * 135;
for(int i = n; i >= 1; i--) {
	for(int j = 1; j <= m; j++) {
		if(i == n) hs[i][j] = sum[i][j] + 2;
		else hs[i][j] = hs[i + 1][j] * 19260817 + sum[i][j] + 2;
	}
}
for(int i = 1; i <= n; i++) {
	for(int j = m - 1; j; j--) {
		hs[i][j] = hs[i][j + 1] * 135 + hs[i][j];
	}
}
```


## 轻重链剖分  

```cpp
void dfs1(int x, int pre) {
	siz[x] = 1; mson[x] = 0;
	dth[x] = dth[pre] + 1;
	fa[x] = pre;
	for(auto y : son[x]) if(y != pre) {
		dfs1(y, x);
		siz[x] += siz[y];
		if(!mson[x] || siz[y] > siz[mson[x]]) 
			mson[x] = y;
	}
}
void dfs2(int x, int pre, int ntp) {
	id[x] = ++idcnt;
	ltp[x] = ntp;
	if(mson[x]) dfs2(mson[x], x, ntp);
	for(auto y : son[x]) {
		if(y == mson[x] || y == pre) continue;
		dfs2(y, x, y);
	}
}
void link_modify(int x, int y, int z) {
	z %= mod;
	while(ltp[x] != ltp[y]) {
		dth[ltp[x]] < dth[ltp[y]] && (x ^= y ^= x ^= y);
		modify(1, n, id[ltp[x]], id[x], 1, z);
		x = fa[ltp[x]];
		
	}
	dth[x] < dth[y] && (x ^= y ^= x ^= y);
	modify(1, n, id[y], id[x], 1, z);
}
int link_query(int x, int y) {
	int ans = 0;
	while(ltp[x] != ltp[y]) {
		dth[ltp[x]] < dth[ltp[y]] && (x ^= y ^= x ^= y);
		ans = (1ll * ans + query(1, n, id[ltp[x]], id[x], 1)) % mod;
		x = fa[ltp[x]];
	}
	dth[x] < dth[y] && (x ^= y ^= x ^= y);
	ans = (1ll * ans + query(1, n, id[y], id[x], 1)) % mod;
	return ans;
}
```

## 线段树合并  
搞个动态开点线段树出来
```cpp
#define mval(x) tree[x].mval
#define mpos(x) tree[x].mpos
#define lson(x) tree[x].lson
#define rson(x) tree[x].rson
struct node {
	int mpos, mval, lson, rson;
} tree[N * 50];
void update(int rt) {
	if(mval(lson(rt)) >= mval(rson(rt))) {
		mval(rt) = mval(lson(rt));
		mpos(rt) = mpos(lson(rt));
	} else {
		mval(rt) = mval(rson(rt));
		mpos(rt) = mpos(rson(rt));
		
	}
}
void modify(int l, int r, int x, int v, int &rt) {
	if(!rt) rt = ++idtot;
	if(l == r) {
		mval(rt) += v;
		mpos(rt) = l;
		return ;
	}
	if(x <= Mid) modify(l, Mid, x, v, lson(rt));
	else modify(Mid + 1, r, x, v, rson(rt));
	update(rt);
}
int merge(int l, int r, int rt1, int rt2) {
	if(!rt1 || !rt2) return rt1 + rt2;
	if(l == r) {
		mval(rt1) += mval(rt2);
		mpos(rt1) = l;
		return rt1;
	}
	lson(rt1) = merge(l, Mid, lson(rt1), lson(rt2));
	rson(rt1) = merge(Mid + 1, r, rson(rt1), rson(rt2));
	update(rt1);
	return rt1;
}
```

## 二维树状数组

+ 矩阵修改，矩阵查询 

> 查询前缀和公式：  
>
> 令$d[i][j]$为差分数组，定义$d[i][j] = a[i][j] - (a[i - 1][j] - a[i][j - 1] - a[i - 1][j])$
>
> $\sum_{i = 1}^{x}\sum_{j - 1}^{y} a[i][j] = (x + 1) * (y + 1) * d[i][j]- (y + 1) * i * d[i][j]+ d[i][j] * i * j$

```cpp
void modify(int x, int y, int v) {
	for(int rx = x; rx <= n; rx += rx & -rx) {
		for(int ry = y; ry <= m; ry += ry & -ry) {
			tree[rx][ry][0] += v;
			tree[rx][ry][1] += v * x;
			tree[rx][ry][2] += v * y;
			tree[rx][ry][3] += v * x * y;
		}
	}
}
void range_modify(int x, int y, int xx, int yy, int v) {
	modify(xx + 1, yy + 1, v);
	modify(x, yy + 1, -v);
	modify(xx + 1, y, -v);
	modify(x, y, v);
}
int query(int x, int y) {
	int ans = 0;
	for(int rx = x; rx; rx -= rx & -rx) {
		for(int ry = y; ry; ry -= ry & -ry) {
			ans += (x + 1) * (y + 1) * tree[rx][ry][0]
			- tree[rx][ry][1] * (y + 1) - tree[rx][ry][2] * (x + 1)
			+ tree[rx][ry][3];
		}
	}
	return ans;
}
int range_query(int x, int y, int xx, int yy) {
	return query(xx, yy) + query(x - 1, y - 1)
		- query(x - 1, yy) - query(xx, y - 1);
}
```


## 平衡树  
+ luogu P3369 【模板】普通平衡树  
```cpp
#define val(x) tree[x].val
#define cnt(x) tree[x].cnt
#define siz(x) tree[x].siz
#define fa(x) tree[x].fa
#define son(x, k) tree[x].ch[k]
struct Tree {
	struct node {
		int val, cnt, siz, fa, ch[2];
	} tree[N];
	int root, tot;
	int chk(int x) {
		return son(fa(x), 1) == x;
	}
	void update(int x) {
		siz(x) = siz(son(x, 0)) + siz(son(x, 1)) + cnt(x);
	}
	void rotate(int x) {
		int y = fa(x), z = fa(y), k = chk(x), w = son(x, k ^ 1);
		son(y, k) = w; fa(w) = y;
		son(z, chk(y)) = x; fa(x) = z;
		son(x, k ^ 1) = y; fa(y) = x;
		update(y); update(x);
	}
	void splay(int x, int goal = 0) {
		while(fa(x) != goal) {
			int y = fa(x), z = fa(y);
			if(z != goal) {
				//双旋
				if(chk(y) == chk(x)) rotate(y);
				else rotate(x);
			}
			rotate(x);
		}
		if(!goal) root = x;
	}
	int New(int x, int pre) {
		tot++;
		if(pre) son(pre, x > val(pre)) = tot;
		val(tot) = x; fa(tot) = pre;
		siz(tot) = cnt(tot) = 1;
		son(tot, 0) = son(tot, 1) = 0;
		return tot;
	}
	void Insert(int x) {
		int cur = root, p = 0;
		while(cur && val(cur) != x) {
			p = cur;
			cur = son(cur, x > val(cur));
		}
		if(cur) cnt(cur)++;
		else cur = New(x, p);
		splay(cur);
	}
	void Find(int x) {
		if(!root) return ;
		int cur = root;
		while(val(cur) != x && son(cur, x > val(cur)))
			cur = son(cur, x > val(cur));
		splay(cur);
	}
	int Pre(int x) {
		Find(x);
		if(val(root) < x) return root;
		int cur = son(root, 0);
		while(son(cur, 1))
			cur = son(cur, 1);
		return cur;
	}
	int Succ(int x) {
		Find(x);
		if(val(root) > x) return root;
		int cur = son(root, 1);
		while(son(cur, 0))
			cur = son(cur, 0);
		return cur;
	}
	void Del(int x) {
		int lst = Pre(x), nxt = Succ(x);
		splay(lst); splay(nxt, lst);
		int cur = son(nxt, 0);
		if(cnt(cur) > 1) cnt(cur)--, splay(cur);
		else son(nxt, 0) = 0, splay(nxt);
	}
	int Kth(int k) {
		int cur = root;
		while(1) {
			if(son(cur, 0) && siz(son(cur, 0)) >= k) cur = son(cur, 0);
			else if(siz(son(cur, 0)) + cnt(cur) >= k) return cur;
			else k -= siz(son(cur, 0)) + cnt(cur), cur = son(cur, 1);
		}
	}
} T;
```

## 可持久化数据结构  

### 可持久化Trie

```cpp
namespace Trie {
	struct node {
		int ch[2], ed, siz;
	} tree[N * 40];
	int tot = 0;
	int _new() {
		tot++;
		tree[tot].ch[0] = 0;
		tree[tot].ch[1] = 0;
		tree[tot].ed = tree[tot].siz = 0;
		return tot;
	}
	void init() {
		tot = 0;
		rt[0] = _new();
	}
	int Insert(int x, int t, int i = 15) {
		int u = _new(), f = (x >> i) & 1;
		tree[u] = tree[t];
		if(i == -1) {
			ed(u)++;
			siz(u)++;
			return u;
		}
		son(u, f) = Insert(x, son(t, f), i - 1);
		siz(u) = siz(son(u, 0)) + siz(son(u, 1));
		return u;
	}
	void print(int u, int now) {
		if(u == 0) return ;
		for(int i = 1; i <= ed(u); i++) printf("%d ", now);
		if(son(u, 0)) print(son(u, 0), now * 2);
		if(son(u, 1)) print(son(u, 1), now * 2 + 1);
	}
	int query(int u1, int u2, int x, int i = 15, int now = 0) {
		if(i == -1) return now;
		int f = (x >> i) & 1;
		if(siz(son(u1, f ^ 1)) - siz(son(u2, f ^ 1)) > 0) 
			return query(son(u1, f ^ 1), son(u2, f ^ 1), x, i - 1, now * 2 + (f ^ 1));
		else return query(son(u1, f), son(u2, f), x, i - 1, now * 2 + (f));
	}
}
```

### 主席树（静态第k小）

建立权值树，那么$[l, r]$的区间权值树就是第$r$个版本减去第$l-1$个版本的树。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <assert.h>
#define Mid ((l + r) / 2)
#define lson (rt << 1)
#define rson (rt << 1 | 1)
using namespace std;
int read() {
	char c; int num, f = 1;
	while(c = getchar(),!isdigit(c)) if(c == '-') f = -1; num = c - '0';
	while(c = getchar(), isdigit(c)) num = num * 10 + c - '0';
	return f * num;
}
const int N = 1e7 + 1009;
const int M = 2e5 + 1009;
struct node {
	int ls, rs, v;
} tree[N];
int tb;
int n, m, tot, a[M], b[M], rt[M];
int _new(int ls, int rs, int v) {
	tree[++tot].ls = ls;
	tree[tot].rs = rs;
	tree[tot].v = v;
	return tot;
}
void update(int rt) {
	tree[rt].v = tree[tree[rt].ls].v + tree[tree[rt].rs].v;
}
int build(int l, int r) {
	if(l == r) return _new(0, 0, 0);
	int x = _new(build(l, Mid), build(Mid + 1, r), 0);
	update(x);
	return x;
}
int add(int l, int r, int p, int rt, int v) {
	int x = ++tot;
	tree[x] = tree[rt];
	if(l == r) {
		tree[x].v += v;
		return x;
	}
	if(p <= Mid) tree[x].ls = add(l, Mid, p, tree[x].ls, v);
	else tree[x].rs = add(Mid + 1, r, p, tree[x].rs, v);
	update(x);
	return x;
}
int query(int l, int r, int rt1, int rt2, int k) {
	if(l == r) return l;
	if(k <= tree[tree[rt1].ls].v - tree[tree[rt2].ls].v) return query(l, Mid, tree[rt1].ls, tree[rt2].ls, k);
	else return query(Mid + 1, r, tree[rt1].rs, tree[rt2].rs, k - (tree[tree[rt1].ls].v - tree[tree[rt2].ls].v));
}
void Debug(int l, int r, int rt) {
	printf("%d %d %d\n", l, r, tree[rt].v);
	if(l == r) return ;
	Debug(l, Mid, tree[rt].ls);
	Debug(Mid + 1, r, tree[rt].rs);
}
signed main()
{
	n = read(); m = read();
	for(int i = 1; i <= n; i++) a[i] = b[i] = read();
	sort(b + 1, b + 1 + n);
	tb = unique(b + 1, b + 1 + n) - b - 1;
	rt[0] = build(1, tb);
	for(int i = 1; i <= n; i++) {
		rt[i] = add(1, tb, lower_bound(b + 1, b + 1 + tb, a[i]) - b, rt[i - 1], 1);
	}
	for(int i = 1; i <= m; i++) {
		int l, r, k;
		l = read(); r = read(); k = read();
		assert(r - l + 1 >= k);
		printf("%d\n", b[query(1, tb, rt[r], rt[l - 1], k)]);
	}
	return 0;
}

```

### cdq分治三维偏序
先按照第一维排序,然后对第二维归并,归并时计算左对右的贡献,先双指针，满足当前统计出的第二维都有序
```cpp
const int N = 1e6 + 1009;
struct node{
	int x, y, z, id, cnt;
}a[N], tmp[N];
bool operator ==(const node &a, const node &b) {
	return a.x == b.x && a.y == b.y && a.z == b.z;
}
int n, m, tot, ans[N], tt[N], tree[N];
int ttt[N];
bool cmp(node a, node b) {
	if(a.x == b.x && a.y == b.y) return a.z < b.z;
	if(a.x == b.x) return a.y < b.y;
	return a.x < b.x;
}
void add(int x, int y) {
	for( ; x <= m; x += x & -x)
		tree[x] += y;
}
int query(int x) {
	int ans = 0;
	for( ; x; x -= x & -x)
		ans += tree[x];
	return ans;
}
void cdq(int l, int r) {
	if(l == r) return ;
	cdq(l, Mid); cdq(Mid + 1, r);
	int i = l, j = Mid + 1, now = l - 1;
	while(i <= Mid && j <= r) {
		if(a[i].y <= a[j].y) {
			tmp[++now] = a[i];
			add(a[i].z, a[i].cnt);
			i++;
		} else {
			tmp[++now] = a[j];
			ans[a[j].id] += query(a[j].z);
			j++;
		}
	}
	while(i <= Mid) {
		tmp[++now] = a[i];
		add(a[i].z, a[i].cnt);
		i++;
	}
	while(j <= r) {
		tmp[++now] = a[j];
		ans[a[j].id] += query(a[j].z);
		j++;
	}
	for(int i = l; i <= Mid; i++) add(a[i].z, -a[i].cnt);
	for(int i = l; i <= r; i++) a[i] = tmp[i];
}
main()
{
	n = read(); m = read();
	for(int i = 1; i <= n; i++) {
		a[i].x = read();
		a[i].y = read();
		a[i].z = read();
		a[i].cnt = 1;
	}
	sort(a + 1, a + 1 + n, cmp);
	for(int i = 1; i <= n; i++) {
		if(i == 1 || !(a[i] == a[i - 1])){
			a[++tot] = a[i];
		}else a[tot].cnt += a[i].cnt;
	}
	for(int i = 1; i <= tot; i++) a[i].id = i, ttt[i] = a[i].cnt;
	cdq(1, tot);
	for(int i = 1; i <= tot; i++) tt[ans[i] + ttt[i] - 1] += ttt[i];
	for(int i = 0; i < n; i++) printf("%d\n", tt[i]);
	return 0;
}
```