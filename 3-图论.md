# 图论

## 树上问题  

### 树的直径  

 [模板：POJ - 1985](http://poj.org/problem?id=1985)

+ 两遍DFS  
```cpp
void dfs(int x, int fa) {
	for(int i = 0; i < E[x].size(); i++) {
		int y = E[x][i].ver;
		int w = E[x][i].val;
		if(y == fa) continue;
		d[y] = d[x] + w;
		if(d[y] > d[c]) c = y;
		dfs(y, x);
	}
}
signed main()
{
	n = read();
	for(int i = 1; i < n; i++) {
		int x = read(), y = read(), w = read();
		E[x].push_back((Edge) {y, w});
		E[y].push_back((Edge) {x, w});
	}
	dfs(1, 0); 
	d[c] = 0;
	dfs(c, 0);
	printf("%d\n", d[c]);
	return 0;
}
```
+ 树形DP  
```cpp
void dfs(int x, int fa) {
	d1[x] = d2[x] = 0;
	for(int i = 0; i < E[x].size(); i++) {
		int y = E[x][i].ver;
		int w = E[x][i].val;
		if(y == fa) continue;
		dfs(y, x);
		int t = d1[y] + w;
		if(t > d1[x]) {
			d2[x] = d1[x];
			d1[x] = t;
		} else if(t > d2[x]) {
			d2[x] = t;
		}
	}
	d = max(d, d1[x] + d2[x]);
}
signed main()
{
	n = read();
	for(int i = 1; i < n; i++) {
		int x = read(), y = read(), w = read();
		E[x].push_back((Edge) {y, w});
		E[y].push_back((Edge) {x, w});
	}
	dfs(1, 0);
	printf("%d\n", d);
	return 0;
}
```

### 求LCA  
+ 树链剖分  
```cpp
namespace Tree {
	int siz[N], mson[N], ltp[N], fa[N], dth[N];
	vector<int> son[N];
	void dfs1(int x, int pre) {
		siz[x] = 1;
		mson[x] = 0;
		fa[x] = pre;
		dth[x] = dth[pre] + 1;
		for(auto y : son[x]) if(y != pre) {
			dfs1(y, x);
			if(mson[x] == 0 || siz[y] > siz[mson[x]]) mson[x] = y;
		}
	}
	void dfs2(int x, int pre, int tp) {
		ltp[x] = tp;
		if(mson[x]) dfs2(mson[x], x, tp);
		for(auto y : son[x]) if(y != pre && y != mson[x]) {
			dfs2(y, x, y);
		}
	}
	void init() {
		dfs1(1, 0);
		dfs2(1, 0, 1);
	}
	int LCA(int x, int y) {
		while(ltp[x] != ltp[y]) {
			if(dth[ltp[x]] > dth[ltp[y]]) x = fa[ltp[x]];
			else y = fa[ltp[y]];
		}
		return dth[y] > dth[x] ? x : y;
	}
}
```
+ 倍增
```cpp
namespace Tree {
	vector<int> son[N];
	int root, fa[N][31], dth[N];
	void dfs(int x, int pre) {
		fa[x][0] = pre;
		dth[x] = dth[pre] + 1;
		for(int i = 1; i <= 30; i++) 
			fa[x][i] = fa[fa[x][i - 1]][i - 1];
		for(auto y : son[x]) if(y != pre)
			dfs(y, x);
	}
	void init() {
		dfs(root, 0);
	}
	int LCA(int x, int y) {
		if(dth[x] > dth[y]) swap(x, y);
		for(int i = 30; ~i; i--) 
			if(dth[fa[y][i]] >= dth[x]) 
				y = fa[y][i];
		if(x == y) return x;
		for(int i = 30; ~i; i--) 
			if(fa[y][i] != fa[x][i]) {
				x = fa[x][i];
				y = fa[y][i];
			}
		return fa[x][0];
	}
}
```

### 树上启发式合并  

长春站的痛.jpg

+ 先递归计算轻儿子的答案
+ 计算重儿子的答案，并且保留重儿子的状态数组
+ 把其他所有轻儿子的答案加到状态数组中，更新当前点的答案

```cpp
void dfs1(int x, int pre) {
	siz[x] = 1;
	mson[x] = 0;
	for(auto y : son[x]) if(y != pre) {
		dfs1(y, x);
		siz[x] += siz[y];
		if(!mson[x] || siz[y] > siz[mson[x]]) mson[x] = y;
	}
}
void add(int x, int pre, int v) {
	cnt[col[x]] += v;
	if(cnt[col[x]] > Mx) Mx = cnt[col[x]], sum = col[x];
	else if(cnt[col[x]] == Mx) sum += col[x];
	for(auto y : son[x]) {
		if(y == pre || y == Son) continue;
		add(y, x, v);
	}
}
void dfs2(int x, int pre, int keep) {
	for(auto y : son[x]) {
		if(y == pre || y == mson[x]) continue;
		dfs2(y, x, 0);
	}
	if(mson[x]) dfs2(mson[x], x, 1), Son = mson[x];
	add(x, pre, 1); Son = 0;
	ans[x] = sum;
	if(!keep) add(x, pre, -1), sum = 0, Mx = 0;
	
}
```



## 图算法  

### 第k短路  
[模板：HDU-6351](http://poj.org/problem?id=2449)

```cpp
bool operator<(const node &a, const node &b) {
	return a.f + a.g > b.f + b.g;
}
priority_queue<node> q;
signed main()
{
	n = read(); m = read();
	for(int i = 1; i <= m; i++) {
		int x, y, w;
		x = read(); y = read(); w = read();
		E[x].push_back((Edge) {y, w});
		re[y].push_back((Edge) {x, w});
	}
	s = read(); t = read(); k = read();
	memset(dis, 0x3f, sizeof(dis)); dis[t] = 0;
	q.push((node) {t, 0, 0});
	while(q.size()) {
		int x = q.top().x, d = q.top().f;
		q.pop();
		if(dis[x] < d) continue;
		for(int i = 0; i < re[x].size(); i++) {
			int y = re[x][i].y, w = re[x][i].w;
			if(dis[y] > dis[x] + w) {
				dis[y] = dis[x] + w;
				q.push((node) {y, dis[y], 0});
			}
		}
	}
	for(int i = 1; i <= n; i++) cnt[i] = k;
	cnt[s]++;
	q.push((node) {s, 0, dis[s]});
	while(q.size()) {
		int x = q.top().x, f = q.top().f, g = q.top().g;
		q.pop();
		if(cnt[x] == 0) continue;
		cnt[x]--;
		if(x == t && cnt[x] == 0) {
			printf("%lld\n", f);
			return 0;
		}
		for(int i = 0; i < E[x].size(); i++) {
			int y = E[x][i].y, w = E[x][i].w;
			q.push((node) {y, f + w, dis[y]});
		}
	}
	printf("-1\n");
	return 0;
}
```

## 网络流

### Dinic算法

```cpp
const int inf = 0x3f3f3f3f;
int bfs() {
	memset(d, 0, sizeof(int) * (t + 10)); d[s] = 1;
	while(q.size()) q.pop(); q.push(s);
	while(q.size()) {
		int x = q.front(); q.pop();
		for(int i = head[x]; i; i = nxt[i]) {
			if(d[ver[i]]) continue;
			if(edge[i] <= 0) continue;
			d[ver[i]] = d[x] + 1;
			q.push(ver[i]);
		}
	}
	return d[t];
}
int dinic(int x, int flow) {
	if(x == t) return flow;
	int k, res = flow;
	for(int i = head[x]; i && res; i = nxt[i]) {
		if(d[ver[i]] != d[x] + 1 || edge[i] <= 0) continue;
		k = dinic(ver[i], min(flow, edge[i]));
		if(k == 0) d[ver[i]] = 0;
		edge[i] -= k;
		edge[i ^ 1] += k;
		res -= k;
	}
	return flow - res;
}
```

### EK算法费用流

```cpp
```

