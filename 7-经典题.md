# 经典题
## 区间回文子串计数（非本质不同）
对于一个询问，考虑一个回文中心向两边拓展，在一个区间左半边的会被左端点挡住，右半边会被右端点挡住。所以我们左右半边分别计算答案。
```
input:
3 3
aba
1 3
1 2
2 2
output:
4
2
1
```
```cpp
const int N = 4e6 + 1009;
namespace manacher {
    char tmp[N];
    int p[N], len;
    void getP(char *s, int n) {
        len = 0;
        for(int i = 0; i < n; i++) {
            tmp[len++] = '#';
            tmp[len++] = s[i];
        }
        tmp[len++] = '#';
        memset(p, 0, sizeof(int) * (len + 10));
        int c = 0, r = 0;
        for(int i = 0; i < len; i++) {
            if(i <= r) p[i] = min(p[2 * c - i], r - i);
            else p[i] = 1;
            while(i - p[i] >= 0 && i + p[i] < len && tmp[i - p[i]] == tmp[i + p[i]]) p[i]++;
            if(i + p[i] - 1 > r) {
                r = i + p[i] - 1;
                c = i;
            }
        }
        for(int i = 0; i < len; i++)p[i]--;
    }
};
struct node {
    int l, r, id;
};
struct SGT {
    long long sum[N];
    int lzt[N];
    int n;
    void set(int x) {
        n = x;
        build(1, n, 1);
    }
    void update(int rt) {
        sum[rt] = sum[lson] + sum[rson];
    }
    void pushdown(int l, int r, int rt) {
        if(lzt[rt] == 0) return ;
        sum[lson] += (Mid - l + 1) * lzt[rt]; lzt[lson] += lzt[rt];
        sum[rson] += (r - Mid) * lzt[rt]; lzt[rson] += lzt[rt];
        lzt[rt] = 0;
    }
    void build(int l, int r, int rt) {
        lzt[rt] = 0;
        if(l == r) {
            sum[rt] = 0;
            return ;
        }
        build(l, Mid, lson);
        build(Mid + 1, r, rson);
        update(rt);
    }
    void modify(int l, int r, int L, int R, int rt, int x) {
        if(L <= l && r <= R) {
            sum[rt] += (r - l + 1) * x;
            lzt[rt] += x;
            return ;
        }
        pushdown(l, r, rt);
        if(L <= Mid) modify(l, Mid, L, R, lson, x);
        if(Mid <  R) modify(Mid + 1, r, L, R, rson, x);
        update(rt);
    }
    long long query(int l, int r, int L, int R, int rt) {
        if(L <= l && r <= R) return sum[rt];
        pushdown(l, r, rt);
        long long ans = 0;
        if(L <= Mid) ans += query(l, Mid, L, R, lson);
        if(Mid <  R) ans += query(Mid + 1, r, L, R, rson);
        return ans;
    }
    long long query(int l, int r) {
        if(l > r) return 0;
        return query(1, n,l, r, 1);
    }
    void modify(int l, int r, int x) {
        if(l > r) return ;
        modify(1, n, l, r, 1, x);
    }
} T;
vector<node> v;
long long ans[N];
int n, q;
char s[N];
void work() {
    cin >> n >> q;
    cin >> s;
    manacher::getP(s, n);
    for(int i = 1; i <= q; i++) {
        int l, r;
        cin >> l >> r;
        l = l * 2 - 1;
        r = r * 2 + 1;
        v.push_back({l, r, i});
    }
    int j = 1;
    std::sort(v.begin(), v.end(), [](const node &a, const node &b) {
        return (a.l + a.r) / 2 < (b.l + b.r) / 2;
    });
    T.set(2 * n + 1);
    for(int i = 0; i < q; i++) {
        int mid = (v[i].l + v[i].r) / 2;
        while(j <= mid) {
            j++;
        }
        ans[v[i].id] += T.query(v[i].l, mid);
    }

    std::sort(v.begin(), v.end(), [](const node &a, const node &b) {
        return (a.l + a.r) / 2 > (b.l + b.r) / 2;
    });
    j = 2 * n + 1;
    T.set(2 * n + 1);
    for(int i = 0; i < q; i++) {
        int mid = (v[i].l + v[i].r) / 2 + 1;
        while(j >= mid) {
            T.modify(j, j + manacher::p[j - 1], 1);
            j--;
        }
        ans[v[i].id] += T.query(mid, v[i].r);
    }
    std::sort(v.begin(), v.end(), [](const node &a, const node &b) {
        return a.id < b.id;
    });
    for(int i = 1; i <= q; i++) {
        ans[i] -= (v[i - 1].r - v[i - 1].l + 2) / 2;
        cout << ans[i] / 2 << endl;
    }
}

```
## 主席树模板（csh）
q次询问，每次询问查询区间l,r内是否存在一个数出现次数超过一半。
```cpp
#include <stdio.h>
#include <stdlib.h>

#define DEBUG printf("Passing [%s] in Line %d\n" , __FUNCTION__ , __LINE__) ;

const int MAX_N = 5e5 + 10 , lgN = 20 + 5 ;

struct Node {
	int num ;
	Node *ch[2] ;
}tre[MAX_N * lgN] ;

int n , m , cur ;
Node *root[MAX_N] ;

void modify(Node *ort , Node *&rt , int x , int y , int f) {
	if (y < f || f < x) return ;

	rt = &tre[cur++] ;
	*rt = *ort ; ++rt->num ;
	if (x == y) return ;

	int mid = (x + y) >> 1 ;
	modify(ort->ch[0] , rt->ch[0] , x , mid , f) ;
	modify(ort->ch[1] , rt->ch[1] , mid + 1 , y , f) ;
}

int find(Node *r1 , Node *r2 , int x , int y , int k) {
	if (x == y) return x ;

	int mid = (x + y) >> 1 ;
	if (r1->ch[0]->num - r2->ch[0]->num >= k) return find(r1->ch[0] , r2->ch[0] , x , mid , k) ;
	else if (r1->ch[1]->num - r2->ch[1]->num >= k) return find(r1->ch[1] , r2->ch[1] , mid + 1 , y , k) ;
	else return 0 ;
}

int main() {
	scanf("%d %d" , &n , &m) ;
	(root[0] = &tre[cur++])->num = 0 ;
	root[0]->ch[0] = root[0]->ch[1] = root[0] ;

	for (int i = 1 ; i <= n ; ++i) {
		int a ; scanf("%d" , &a) ;
		modify(root[i - 1] , root[i] , 1 , n , a) ;
	}

	///

	for (; m-- ;) {
		int x , y , len , k ;
		scanf("%d %d" , &x , &y) ;
		len = y - x + 1 ; k = len / 2 + 1 ;

		printf("%d\n" , find(root[y] , root[x - 1] , 1 , n , k)) ;
	}

	return 0 ;
}
```