#  杂项
## int128

```cpp
typedef __uint128_t u128;
inline u128 read() {
    static char buf[100];
    scanf("%s", buf);
    // std::cin >> buf;
    u128 res = 0;
    for(int i = 0;buf[i];++i) {
        res = res << 4 | (buf[i] <= '9' ? buf[i] - '0' : buf[i] - 'a' + 10);
    }
    return res;
}
inline void output(u128 res) {
    if(res >= 16)
        output(res / 16);
    putchar(res % 16 >= 10 ? 'a' + res % 16 - 10 : '0' + res % 16);
    //std::cout.put(res % 16 >= 10 ? 'a' + res % 16 - 10 : '0' + res % 16);
}
```
## 奇技淫巧  
**_builtin_内建函数** 

+ __builtin_popcount(unsigned int n) 该函数是判断n的二进制中有多少个1    
+ __builtin_parity(unsigned int n) 该函数是判断n的二进制中1的个数的奇偶性  
+ __builtin_ffs(unsigned int n) 该函数判断n的二进制末尾最后一个1的位置，从一开始  
+ __builtin_ctz(unsigned int n) 该函数判断n的二进制末尾后面0的个数，当n为0时，和n的类型有关  
+ __builtin_clz (unsigned int x) 返回前导的0的个数  


**T(5)求任意int log2**  
```cpp
inline int LOG2_1(unsigned x){
    static const int tb[32]={0,9,1,10,13,21,2,29,11,14,16,18,22,25,3,30,8,12,20,28,15,17,24,7,19,27,23,6,26,5,4,31};
    x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16;
    return tb[x*0x07C4ACDDu>>27];
}
```
**O(1)求2的整幂次log2**  
```cpp
inline int LOG2(unsigned x){  //x=2^k
    static const int tb[32]={31,0,27,1,28,18,23,2,29,21,19,12,24,9,14,3,30,26,17,22,20,11,8,13,25,16,10,7,15,6,5,4};
    return tb[x*263572066>>27];
}
```



## 快速乘  
```cpp
inline long long mul(long long x, long long y, long long mod){
    return (x * y - (long long)((long double)x / mod * y) * mod + mod) % mod;     
}
```
## tips:

+ 如果使用 sort 比较两个函数，不能出现$a<b$和$a>b$同时为真的情况，否则会运行错误。
+ 多组数据清空线段树的时候，不要忘记清空全部数组（比如说lazytag数组）。

+ 注意树的深度和节点到根的距离是两个不同的东西，深度是点数，距离是边长，如果求LCA时用距离算会出错。

+ 连通性专题：注意判断$dfn[x]$和$low[y]$的关系时是否不小心两个都达成$low$了
