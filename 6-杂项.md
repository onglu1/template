#  杂项
## int128
```cpp
typedef __uint128_t u128;
inline u128 read() {
    static char buf[100];
    scanf("%s", buf);
    // std::cin >> buf;
    u128 res = 0;
    for(int i = 0;buf[i];++i) {
        res = res << 4 | (buf[i] <= '9' ? buf[i] - '0' : buf[i] - 'a' + 10);
    }
    return res;
}
inline void output(u128 res) {
    if(res >= 16)
        output(res / 16);
    putchar(res % 16 >= 10 ? 'a' + res % 16 - 10 : '0' + res % 16);
    //std::cout.put(res % 16 >= 10 ? 'a' + res % 16 - 10 : '0' + res % 16);
}
```
## Java,BigInteger  
```java
public BigInteger add(BigInteger val)   返回当前大整数对象与参数指定的大整数对象的和
public BigInteger subtract(BigInteger val)  返回当前大整数对象与参数指定的大整数对象的差
public BigInteger multiply(BigInteger val)   返回当前大整数对象与参数指定的大整数对象的积
public BigInteger devide(BigInteger val)    返回当前大整数对象与参数指定的大整数对象的商
public BigInteger remainder(BigInteger val)    返回当前大整数对象与参数指定的大整数对象的余
public int compareTo(BigInteger val)    返回当前大整数对象与参数指定的大整数对象的比较结果，返回值是1、-1、0，分别表示当前大整数对象大于、小于或等于参数指定的大整数。
public BigInteger abs()    返回当前大整数对象的绝对值
public BigInteger pow(int exponent)   返回当前大整数对象的exponent次幂。
public String toString()    返回当前当前大整数对象十进制的字符串表示。
public String toString(int p)   返回当前大整数对象p进制的字符串表示。
public BigInteger negate()   返回当前大整数的相反数。
```

## 奇技淫巧  
**_builtin_内建函数** 

+ __builtin_popcount(unsigned int n) 该函数是判断n的二进制中有多少个1    
+ __builtin_parity(unsigned int n) 该函数是判断n的二进制中1的个数的奇偶性  
+ __builtin_ffs(unsigned int n) 该函数判断n的二进制末尾最后一个1的位置，从一开始  
+ __builtin_ctz(unsigned int n) 该函数判断n的二进制末尾后面0的个数，当n为0时，和n的类型有关  
+ __builtin_clz (unsigned int x) 返回前导的0的个数  

**随机数种子**
```cpp
srand(std :: chrono :: system_clock :: now().time_since_epoch().count());
```

**T(5)求任意int log2**  
```cpp
inline int LOG2_1(unsigned x){
    static const int tb[32]={0,9,1,10,13,21,2,29,11,14,16,18,22,25,3,30,8,12,20,28,15,17,24,7,19,27,23,6,26,5,4,31};
    x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16;
    return tb[x*0x07C4ACDDu>>27];
}
```
**O(1)求2的整幂次log2**  
```cpp
inline int LOG2(unsigned x){  //x=2^k
    static const int tb[32]={31,0,27,1,28,18,23,2,29,21,19,12,24,9,14,3,30,26,17,22,20,11,8,13,25,16,10,7,15,6,5,4};
    return tb[x*263572066>>27];
}
```

**开启编译优化**  
```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC target("avx","sse2")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
```



## 快速乘  
```cpp
ll mul(ll x, ll y, ll mod){
    return (x * y - (ll)((long double)x / mod * y) * mod + mod) % mod;     
}
ll mul(ll a, ll b, ll MOD) {
    __int128 x = a, y = b, m = MOD;
    return (ll)(x * y % m);
}
```
## tips:

+ 如果使用 sort 比较两个函数，不能出现$a<b$和$a>b$同时为真的情况，否则会运行错误。
+ 多组数据清空线段树的时候，不要忘记清空全部数组（比如说lazytag数组）。

+ 注意树的深度和节点到根的距离是两个不同的东西，深度是点数，距离是边长，如果求LCA时用距离算会出错。

+ 连通性专题：注意判断$dfn[x]$和$low[y]$的关系时是否不小心两个都达成$low$了
