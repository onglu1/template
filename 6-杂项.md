#  杂项
## int128

```cpp
typedef __uint128_t u128;
inline u128 read() {
    static char buf[100];
    scanf("%s", buf);
    // std::cin >> buf;
    u128 res = 0;
    for(int i = 0;buf[i];++i) {
        res = res << 4 | (buf[i] <= '9' ? buf[i] - '0' : buf[i] - 'a' + 10);
    }
    return res;
}
inline void output(u128 res) {
    if(res >= 16)
        output(res / 16);
    putchar(res % 16 >= 10 ? 'a' + res % 16 - 10 : '0' + res % 16);
    //std::cout.put(res % 16 >= 10 ? 'a' + res % 16 - 10 : '0' + res % 16);
}
```

## _builtin_内建函数  

+ __builtin_popcount(unsigned int n) 该函数是判断n的二进制中有多少个1    
+ __builtin_parity(unsigned int n) 该函数是判断n的二进制中1的个数的奇偶性  
+ __builtin_ffs(unsigned int n) 该函数判断n的二进制末尾最后一个1的位置，从一开始  
+ __builtin_ctz(unsigned int n) 该函数判断n的二进制末尾后面0的个数，当n为0时，和n的类型有关  
+ __builtin_clz (unsigned int x) 返回前导的0的个数  

## 快速乘  
```cpp
inline long long mul(long long x, long long y, long long mod){
    return (x * y - (long long)((long double)x / mod * y) * mod + mod) % mod;     
}
```
## tips:

+ 如果使用 sort 比较两个函数，不能出现$a<b$和$a>b$同时为真的情况，否则会运行错误。
+ 多组数据清空线段树的时候，不要忘记清空全部数组（比如说lazytag数组）。

+ 注意树的深度和节点到根的距离是两个不同的东西，深度是点数，距离是边长，如果求LCA时用距离算会出错。

+ 连通性专题：注意判断$dfn[x]$和$low[y]$的关系时是否不小心两个都达成$low$了
