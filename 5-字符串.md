# 字符串  

## 字串哈希

```cpp
namespace String {
	const int x = 135;
	const int p1 = 1e9 + 7, p2 = 1e9 + 9;
	ull xp1[N], xp2[N], xp[N];
	void init_xp() {
		xp1[0] = xp2[0] = xp[0] = 1;
		for(int i = 1; i < N; i++) {
			xp1[i] = xp1[i - 1] * x % p1;
			xp2[i] = xp2[i - 1] * x % p2;
			xp[i] = xp[i - 1] * x;
		}
	}
	struct HashString {
		char s[N];
		int length, subsize;
		bool sorted;
		ull h[N], hl[N];
		ull init(const char *t) {
			if(xp[0] != 1) init_xp();
			length = strlen(t);
			strcpy(s, t);
			ull res1 = 0, res2 = 0;
			h[length] = 0;
			for(int j = length - 1; j >= 0; j--) {
			#ifdef ENABLE_DOUBLE_HASH
	            res1 = (res1 * x + s[j]) % p1;
	            res2 = (res2 * x + s[j]) % p2;
	            h[j] = (res1 << 32) | res2;
	        #else
	            res1 = res1 * x + s[j];
	            h[j] = res1;
	        #endif
			}
			return h[0];
		}
		//获取子串哈希，左闭右开
		ull get_substring_hash(int left, int right)  {
			int len = right - left;
		#ifdef ENABLE_DOUBLE_HASH
			unsigned int mask32 = ~(0u);
			ull left1 = h[left] >> 32, right1 = h[right] >> 32;
	        ull left2 = h[left] & mask32, right2 = h[right] & mask32;
	        return (((left1 - right1 * xp1[len] % p1 + p1) % p1) << 32) |
	               (((left2 - right2 * xp2[len] % p2 + p2) % p2));
		#else
			return h[left] - h[right] * xp[len];
		#endif
		}
		void get_all_subs_hash(int sublen) {
	        subsize = length - sublen + 1;
	        for (int i = 0; i < subsize; ++i)
	            hl[i] = get_substring_hash(i, i + sublen);
	        sorted = 0;
	    }
	
	    void sort_substring_hash() {
	        sort(hl, hl + subsize);
	        sorted = 1;
	    }
	
	    bool match(ull key) const {
	        if (!sorted) assert (0);
	        if (!subsize) return false;
	        return binary_search(hl, hl + subsize, key);
	    }
	};
}
```

## 后缀数组  
sa[i]定义为字典序排名第i的后缀的起始位置。  
rk[i]定义为以i起始的后缀的排名。  
height[i]定义为sa[i]和sa[i - 1]的最长公共前缀的长度。  
定义h[i]为排名第i的字符串和排名第i - 1的字符串的最长公共前缀长度。  
有height[i]>=height[i - 1] - 1。  
$lcp(sa[i], sa[j]) = min(lcp(sa[i], sa[k]), lcp(sa[k], sa[j])) \forall sa[i] \le sa[k] \le sa[j]$  
$lcp(sa[i], sa[j]) = min\{height[i + 1,\cdots,j]\}$

```cpp
int sa[N], id[N], rk[N], oldrk[N], cnt[N], height[N];
void get_sa(char *c) {
    n = strlen(c + 1);
    m = 300;
    for(int i = 1; i <= n; i++) cnt[rk[i] = c[i]]++;
    for(int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
    for(int i = n; i >= 1; i--) sa[cnt[rk[i]]--] = i;
    for(int w = 1; w < n; w <<= 1) {
        int tt = 0;
        for(int i = 1; i <= w; i++) id[++tt] = i + n - w;
        for(int i = 1; i <= n; i++) if(sa[i] > w) {
                id[++tt] = sa[i] - w;
            }
        memset(cnt, 0, sizeof(int) * (m + 1));
        for(int i = 1; i <= n; i++) cnt[rk[i]]++;
        for(int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
        for(int i = n; i >= 1; i--) sa[cnt[rk[id[i]]]--] = id[i];
        memcpy(oldrk, rk, sizeof(int) * (n + 1));
        int p = 1;
        rk[sa[1]] = 1;
        for(int i = 2; i <= n; i++) {
            rk[sa[i]] = (oldrk[sa[i]] == oldrk[sa[i - 1]] && oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) ? p : ++p;
        }
        if(p == n) break;
        m = p;
    }
}
void get_height(char *c) {
    for(int i = 1, k = 0; i <= n; i++) {
        if(rk[i] == 1) continue;
        if(k) k--;
        int j = sa[rk[i] - 1];
        while(i + k <= n && j + k <= n && c[i + k] == c[j + k]) k++;
        height[rk[i]] = k;
    }
}
```

### SA-IS
会开两倍空间，如果传入的是整数数组，字符集请从1开始，不能出现0。
```cpp
template<size_t size>
struct suffix_array {
    bool type[size << 1];
    int ht[size], rk[size], sa[size], bk[size], bk1[size];

    inline bool isLMS(int i, bool *type) {
        return (i > 0 && type[i] && !type[i - 1]);
    }

    template<class T>
    inline void induced_sort(T s, int *sa, int len, int bs, int sigma,
                             bool *type, int *bk, int *cb, int *p) {
        memset(bk, 0, sizeof(int) * sigma), memset(sa, -1, sizeof(int) * len);
        for (int i = 0; i < len; ++i) bk[s[i]]++;
        cb[0] = bk[0];
        for (int i = 1; i < sigma; ++i) cb[i] = cb[i - 1] + bk[i];
        for (int i = bs - 1; i >= 0; --i) sa[--cb[s[p[i]]]] = p[i];
        for (int i = 1; i < sigma; ++i) cb[i] = cb[i - 1] + bk[i - 1];
        for (int i = 0; i < len; ++i)
            if (sa[i] > 0 && !type[sa[i] - 1])
                sa[cb[s[sa[i] - 1]]++] = sa[i] - 1;
        cb[0] = bk[0];
        for (int i = 1; i < sigma; ++i) cb[i] = cb[i - 1] + bk[i];
        for (int i = len - 1; i >= 0; --i)
            if (sa[i] > 0 && type[sa[i] - 1])
                sa[--cb[s[sa[i] - 1]]] = sa[i] - 1;
    }

    template<class T>
    inline void sais(T s, int *sa, int len, bool *type, int *bk,
                     int *bk1, int sigma) {
        int p = -1, j, cnt = 0, bs = 0, *cb = bk + sigma, x;
        type[len - 1] = true;
        for (int i = len - 2; i >= 0; --i)
            type[i] = (s[i] < s[i + 1] || (s[i] == s[i + 1] && type[i + 1]));
        for (int i = 1; i < len; ++i)
            if (type[i] && !type[i - 1]) bk1[bs++] = i;
        induced_sort(s, sa, len, bs, sigma, type, bk, cb, bk1);
        for (int i = bs = 0; i < len; ++i)
            if (isLMS(sa[i], type)) sa[bs++] = sa[i];
        for (int i = bs; i < len; ++i) sa[i] = -1;
        for (int i = 0; i < bs; ++i) {
            x = sa[i];
            for (int j = 0; j < len; ++j) {
                if (p == -1 || s[x + j] != s[p + j] || type[x + j]
                                                       != type[p + j]) { cnt++, p = x; break; }
                else if (j > 0 && (isLMS(p + j, type)
                                   || isLMS(x + j, type))) break;
            }
            x >>= 1, sa[bs + x] = cnt - 1;
        }
        for (int i = j = len - 1; i >= bs; --i)
            if (sa[i] >= 0) sa[j--] = sa[i];
        int *s1 = sa + len - bs, *bk2 = bk1 + bs;
        if (cnt < bs) sais(s1, sa, bs, type + len, bk, bk2, cnt);
        else for (int i = 0; i < bs; ++i) sa[s1[i]] = i;
        for (int i = 0; i < bs; ++i) bk2[i] = bk1[sa[i]];
        induced_sort(s, sa, len, bs, sigma, type, bk, cb, bk2);
    }

    template<class T>
    inline void get_height(T *s, int len, int *sa) {
        for (int i = 0, k = 0; i < len; ++i) {
            if (rk[i] == 0) k = 0;
            else {
                if (k > 0) k--;
                int j = sa[rk[i] - 1];
                while (i + k < len && j + k < len && s[i + k] == s[j + k]) k++;
            }
            ht[rk[i]] = k;
        }
    }

    template<class T>
    inline void init(T s, int len, int sigma = 124) {
        // len是字符串长度， sigma是字符集大小
        // 计算完sa[1...len]，存放0...len-1，表示排名第i的后缀的开始位置
        // rk[0...len-1]表示从i开始的后缀的排名
        // h[2...len]表示排名为i的后缀，与排名为i-1的后缀的lcp是多少
        len += 1;
        sais(s, sa, len, type, bk, bk1, sigma);
        for (int i = 1; i < len; ++i) rk[sa[i]] = i;
        get_height(s, len, sa);
    }
};
```

## SAM
字符集要放缩到0-sigma
```cpp
template<size_t size, size_t sigma>
struct SAM{
    int ch[size << 1][sigma], fail[size << 1], siz[size << 1], len[size << 1], endpos[size << 1];
    int t[size << 1], A[size << 1];
    //int jump[size << 1][19], endsta[size << 1];
    long long cnt[size << 1];
    int num = 1, last = 1;
    void insert(int c, int pos) {
        int now = ++ num, node = last;
        len[now] = len[last] + 1;
        siz[now] = 1; endpos[now] = pos;
        //endsta[pos] = now;
        while(node && !ch[node][c]) ch[node][c] = now, node = fail[node];
        if(!node) fail[now] = 1;
        else {
            int cur = ch[node][c];
            if(len[cur] == len[node] + 1) fail[now] = cur;
            else {
                int clone = ++ num;
                for(int i = 0; i < sigma; i ++) ch[clone][i] = ch[cur][i];
                len[clone] = len[node] + 1;
                fail[clone] = fail[cur];
                while(node && ch[node][c] == cur)
                    ch[node][c] = clone, node = fail[node];
                fail[now] = fail[cur] = clone;
            }
        }
        last = now;
    }
    void prework() {
        for(int i = 1; i <= num; i ++) t[len[i]] ++;
        for(int i = 1; i <= num; i ++) t[i] += t[i - 1];
        for(int i = 1; i <= num; i ++) A[t[len[i]] --] = i;
        for(int i = num; i >= 1; i --)
            siz[fail[A[i]]] += siz[A[i]],
                    endpos[fail[A[i]]] = max(endpos[fail[A[i]]], endpos[A[i]]);
        for(int i = 1; i <= num; i ++)
            cnt[A[i]] = cnt[fail[A[i]]] + 1ll * (len[A[i]] - len[fail[A[i]]]) * siz[A[i]];
		// for(int i = 1; i <= num; i++) jump[i][0] = fail[i];
		// jump[1][0] = 1;
        // for(int j = 1; j < 19; j++) {
        //     for(int i = 1; i <= num; i++) {
        //         jump[i][j] = jump[jump[i][j - 1]][j - 1];
        //     }
        // }
    }
    void clear() {
        memset(len, 0, sizeof(int) * (num + 1));
        memset(fail, 0, sizeof(int) * (num + 1));
        memset(cnt, 0, sizeof(int) * (num + 1));
        memset(endpos, 0, sizeof(int) * (num + 1));
        memset(siz, 0, sizeof(int) * (num + 1));
        memset(t, 0, sizeof(int) * (num + 1));
        memset(A, 0, sizeof(int) * (num + 1));
        memset(ch, 0, sizeof(int) * (num + 1) * sigma);
        last = num = 1;
    }
	void build(const string &s) {
        clear();
        for(int i = 0; i < s.size(); i++) insert(s[i] - 'a', i);
        prework();
    }
	// int fidNode(int l, int r) {
	// 	// 定位子串[l, r]对应的节点
    //     int now = endsta[r];
    //     for(int i = 18; i >= 0; i--) {
    //         if(len[jump[now][i]] >= (r - l + 1)) {
    //             now = jump[now][i];
    //         }
    //     }
    //     return now;
    // }
};
SAM<N, 26> sam;
```
## 后缀树  
后缀树是将字符串的所有后缀插入到Trie树里面形成的数据结构，它等于字符串反串SAM的parent树。

```cpp
// 放到SAM的prework中
for(int i = 2; i <= num; i++) {
    ver[fail[i]].push_back({s[endpos[i] - len[fail[i]]] - 'a', i});
}
// 字典序
for(int i = 1; i <= num; i++) std::sort(ver[i].begin(), ver[i].end());
```

## Trie

```cpp
namespace trie {
	int t[N][26], sz, ed[N];
	int _new() {
		sz++;
		memset(t[sz], 0, sizeof(t[sz])); 
		return sz;
	}
	void init() {
		sz = 0;
		_new();
		memset(ed, 0, sizeof(ed));
	}
	void Insert(char *s, int n) {
		int u = 1;
		for(int i = 0; i < n; i++) {
			int c = s[i] - 'a';
			if(!t[u][c]) t[u][c] = _new();
			u = t[u][c];
		}
		ed[u]++;
	}
	int find(char *s, int n) {
		int u = 1;
		for(int i = 0; i < n; i++) {
			int c = s[i] - 'a';
			if(!t[u][c]) return -1;
			u = t[u][c];
		}
		return u;
	}
}
```



## KMP算法

```cpp
namespace KMP {
	void get_next(char *t, int m, int *nxt) {
		int j = nxt[0] = 0;
		for(int i = 1; i < m; i++) {
			while(j && t[i] != t[j]) j = nxt[j - 1];
			nxt[i] = j += (t[i] == t[j]);
		}
	}
	vector<int> find(char *t, int m, int *nxt, char *s, int n) {
		vector<int> ans;
		int j = 0;
		for(int i = 0; i < n; i++) {
			while(j && s[i] != t[j]) j = nxt[j - 1];
			j += s[i] == t[j];
			if(j == m) {
				ans.push_back(i - m + 1);
				j = nxt[j - 1];
			}
		}
		return ans;
	}
}
```





## manacher算法
p数组代表的是插入'#'的串的每个点开始的最长回文半径  
比如#a#b#a#的p[3] = 4，表示从b开始往外3个字母是最大的回文串  
s和p都是从0开始的。
```cpp
namespace manacher {
	char tmp[N];
	int p[N], len;
	void getP(char *s, int n) {
		len = 0;
		for(int i = 0; i < n; i++) {
			tmp[len++] = '#';
			tmp[len++] = s[i];
		}
		tmp[len++] = '#';
		memset(p, 0, sizeof(int) * (len + 10));
		int c = 0, r = 0;
		for(int i = 0; i < len; i++) {
			if(i <= r) p[i] = min(p[2 * c - i], r - i);
			else p[i] = 1;
			while(i - p[i] >= 0 && i + p[i] < len && tmp[i - p[i]] == tmp[i + p[i]])
				p[i]++;
			if(i + p[i] - 1 > r) {
				r = i + p[i] - 1;
				c = i;
			}
		}
	}
	int getlen() {
		return *max_element(p, p + len);
	}
	int getlen(string s) {
		getP(s);
		return getlen();
	}
}
```

## 回文自动机
回文自动机中，每个点表示一个本质不同的回文串。  
有两个根，偶根0，长度为0，奇根1，长度为-1.   
偶根的fail指向奇根，奇根没有fail，因为不可能失配(匹配后长度为1)。   
fail表示一个点的最长回文后缀  
cnt表示当前节点所能代表的回文串的数量  
text表示文本  
son[x][y]表示x点的回文串，前后各加一个y，形成新的回文串。  

```cpp
namespace PAM {
    int all, son[N][S], fail[N], cnt[N], len[N], text[N], last, tot;
    int newnode(int l) {
        memset(son[tot], 0, sizeof(int) * (S));
        cnt[tot] = 0; len[tot] = l;
        return tot++;
    }
    void init() {
        last = tot = all = 0;
        newnode(0); newnode(-1);
        text[0] = -1; fail[0] = 1;
    }
    int getfail(int x) {
        while(text[all - len[x] - 1] != text[all]) x = fail[x];
        return x;
    }
    void add(int w) {
        text[++all] = w;
        int x = getfail(last);
        if(!son[x][w]) {
            int y = newnode(len[x] + 2);
            fail[y] = son[getfail(fail[x])][w];
            son[x][w] = y;
        }
        cnt[last = son[x][w]]++;
    }
    void count() {for(int i = tot - 1; ~i; i--) cnt[fail[i]] += cnt[i];}
}
```


## AC自动机

```cpp
struct ac_automaton {
	int t[N][26], danger[N], tot, fail[N];
	int dp[N][N];
	void init() {
		tot = -1;
		_new();	
	}
	int _new() {
		tot++;
		memset(t[tot], 0, sizeof(t[tot]));
		danger[tot] = 0;
		fail[tot] = 0;
		return tot;
	}
	void Insert(const char *s) {
		int u = 0;
		for(int i = 0; s[i]; i++) {
			if(!t[u][mp[s[i]]]) t[u][s[i] - 'a'] = _new();
			u = t[u][mp[s[i]]];
		}
		danger[u] = 1;
	}
	void build() {
		queue<int> q;
		for(int i = 0; i < 26; i++) {
			if(t[0][i]) {
				fail[t[0][i]] = 0;
				q.push(t[0][i]);
			}
		}
		while(q.size()) {
			int u = q.front(); q.pop();
			danger[u] |= danger[fail[u]];
			for(int i = 0; i < 26; i++) {
				if(t[u][i]) {
					fail[t[u][i]] = t[fail[u]][i];
					q.push(t[u][i]);
				} else t[u][i] = t[fail[u]][i];
			}
		}
	}
	int query(const char *s) {
		memset(dp, 0x3f, sizeof(dp));
		int n = strlen(s);
		dp[0][0] = 0;
		for(int i = 0; i < n; i++) {
			for(int j = 0; j <= tot; j++) if(!danger[j]) {
				for(int k = 0; k < 26; k++) if(!danger[t[j][k]]) {
					dp[i + 1][t[j][k]] = min(dp[i + 1][t[j][k]], dp[i][j] + (s[i] - 'a' != k));
				}
			}
		}
		int ans = 0x3f3f3f3f;
		for(int i = 0; i <= tot; i++) if(!danger[i]) {
			ans = min(ans, dp[n][i]);
		}
		return ans == 0x3f3f3f3f ? -1 : ans;
	}
};
```



# 区间本质不同子串个数
```cpp
// 写一个线段树，写一个SAM（记录每个字符加入时对应的节点位置），补全LCT的splay，rotate
struct LCT {
    void pushtag(int x, int y) {
        if(x == 0) return;
        val[x] = y;
        tag[x] = y;
    }
    void pushdown(int x) {
        if(tag[x]) {
            if(ch[x][0]) pushtag(ch[x][0], tag[x]);
            if(ch[x][1]) pushtag(ch[x][1], tag[x]);
            tag[x] = 0;
        }
    }
    void access(int x, int v) {
        int y;
        for(y = 0; x; y = x, x = fa[x]) {
            splay(x);
            ch[x][1] = y;
            if(val[x]) {
                sgt.modify(val[x] - sam.len[x] + 1, val[x] - sam.len[fa[x]], -1);
            }
        }
        pushtag(y, v); sgt.modify(1, v, 1);
    }
} lct;
string s;
vector<pair<int, int> > v[N];
int n, ans[N];
void work() {
    cin >> s;
    cin >> n;
    sgt.setLimit(s.size() + 3);
    for(int i = 1; i <= n; i++) {
        int l, r;
        cin >> l >> r;
        v[r].push_back({i, l});
    }
    for(int i = 0; i < s.size(); i++) sam.insert(s[i] - 'a', i + 1);
    for(int i = 2; i <= sam.num; i++) lct.fa[i] = sam.fail[i];
    for(int i = 1; i <= s.size(); i++) {
        lct.access(sam.p[i], i);
        for(auto item : v[i]) {
            ans[item.first] = sgt.query(item.second, i);
        }
    }
    for(int i = 1; i <= n; i++) cout << ans[i] << endl;
}
```