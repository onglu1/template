# 数学
## 多项式  
### 结论  
1. 自然数幂之和$s(n) = \sum_{i = 0}^n i^k$是关于$n$的$k+1$次多项式  


### 拉格朗日插值法  
令拉格朗日函数  
$$l_i(x) = \prod_{j \not = i}\frac{x - x_j}{x_i-x_j}$$
注意到这个函数有一些性质：  
1. 次数为$n$  
2. 在$x=x_i$位置值为$1$,$x=x_j(j\not =i)$位置值为$0$  
于是可以凑出唯一的多项式表达式为：  
$$f(x) = \sum_{i=0}^{n}y_i\prod_{j\not = i}\frac{x - x_j}{x_i-x_j}$$  
如果要取模的话得求逆元，逆元先求好分母再一起求即可。  
```cpp
int interpolation(int *x, int *y, int n) {
    int f = 0;
    for(int i = 1; i <= n; i++) {
        int s1 = 1, s2 = 1;
        for(int j = 1; j <= n; j++) {
            if(i != j) {
                s1 = 1ll * s1 * (k - x[j] + mod) % mod;
                s2 = 1ll * s2 * (x[i] - x[j] + mod) % mod;
            }
        }
        f = (f + 1ll * y[i] * s1 % mod * inv(s2) % mod) % mod;
    }
    return f;
}

```
### FFT快速傅里叶变换    
FFT的想法是把第$k$号位置变成$f(\omega _n ^k)$，注意到$\omega _n ^k = -\omega _n ^{k + n / 2}$，于是可以进行变换。  
**几条公式：** 
$$\omega _n ^n = 1$$
$$\omega _n ^k = \omega _{2n} ^{2k}$$  
$$\omega _{2n} ^ {k + n} = -\omega _{2n} ^k$$

蝴蝶变换：相邻的位置为二进制的reverse  
DFT变换公式($DFT(f)$为矩阵)：  
令
$$G(x) = a_0 + a_2x + a_4x^2 + \dots$$
$$H(x) = a_1 + a_3x + a_5x^3 + \dots$$
则有
$$f(x) = G(x^2) + x \times H(x^2)$$
$$DFT(f(\omega _n ^k)) = DFT(G(\omega _{n/2} ^k) + \omega _n ^k \times DFT(H(\omega _{n/2} ^k)))$$
$$DFT(f(\omega _n ^{k + n / 2})) = DFT(G(\omega _{n/2} ^k) - \omega _n ^k \times DFT(H(\omega _{n/2} ^k)))$$

$DFT(G(\omega _{n/2} ^k), DFT(H(\omega _{n/2} ^k)))$可递归计算  


```cpp
const int P = 998244353, G = 3, Gi = 332748118;
struct Complex {double x, y;};
Complex operator+(const Complex &a, const Complex &b) {return (Complex) {a.x + b.x, a.y + b.y};}
Complex operator-(const Complex &a, const Complex &b) {return (Complex) {a.x - b.x, a.y - b.y};}
Complex operator*(const Complex &a, const Complex &b) {return (Complex) {a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x};}
namespace Polynomial {
	const double Pi = acos(-1.0);
	int rev[N];
	template <typename T>
	void change(T *y, int n) {
		for(int i = 0; i < n; i++) {
			rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (n >> 1) : 0);
		}
		for(int i = 0; i < n; i++) 
			if(i < rev[i])
				swap(y[i], y[rev[i]]);
	}
	void FFT(Complex *A, int n, int type) {
		//type = 1 DFT 
		//type = -1 IDFT 
        //确保n是2的幂次
		change(A, n);
		for(int m = 1; m < n; m <<= 1) {
			Complex Wn = (Complex) {cos(Pi / m), type * sin(Pi / m)};
			for(int i = 0; i < n; i += 2 * m) {
				Complex w = (Complex) {1.0, 0};
				for(int j = 0; j < m; j++, w = w * Wn) {
					Complex x = A[i + j], y = w * A[i + j + m];
					A[i + j] = x + y;
					A[i + j + m] = x - y;
				} 
			}
		}
		if(type == -1) {
			for(int i = 0; i < n; i++)
				A[i].x = A[i].x / n;
		}
	}
	void NTT(int *A, int n, int type) {
		//type = 1 DFT 
		//type = -1 IDFT 
		change(A, n);
		for(int m = 1; m < n; m <<= 1) {
			int Wn = qpow(type == 1 ? G : Gi, (P - 1) / (m << 1));
			for(int i = 0; i < n; i += 2 * m) {
				int w = 1;
				for(int j = 0; j < m; j++, w = 1ll * w * Wn % P) {
					int x = A[i + j], y = 1ll * w * A[i + j + m] % P;
					A[i + j] = (x + y) % P;
					A[i + j + m] = (x - y + P) % P;
				} 
			}
		}
		if(type == -1) {
			int inv = qpow(n, P - 2);
			for(int i = 0; i < n; i++)
				A[i] = 1ll * A[i] * inv % P;
		}
	}
	
}
//以下代码加在主函数内  
limit = 1;
while(limit <= n + m) limit <<= 1;
Polynomial :: FFT(A, limit, 1); 
Polynomial :: FFT(B, limit, 1);
for(int i = 0; i < limit; i++) A[i] = A[i] * B[i];
Polynomial :: FFT(A, limit, -1);
```

### NTT快速数论变换  
NTT使用原根代替复数进行运算。  
原根$g$的重要性质：$g^t\equiv k\mod{n} ,t\in [0,n - 2]$，$k$遍取$1$~$n-1$  
原根存在的充要条件是：模数$n = 2, 4, p^\alpha, 2p^\alpha$($p$为奇质数)。    
对于一个质数$p=qn+1(n=2^m)$,原根满足性质$g^{qn}\equiv 1\mod{p}$。  
它满足和复数近似的性质，我们把$q$看成复数中的$2\pi$，就可以套用FFT实现NTT了。  
$g _n ^n \equiv 1, g _n ^n \equiv -1$  

通常取  
$$p = 1004535809 = 7 \times 479 \times 2^{21} + 1, g = 3$$  
$$p = 998244353 = 7 \times 17 \times 2^{23} + 1, g = 3$$



## 群论  
### 结论  
1. **子群检验法**:群$G$是群$H$的子群的充分必要条件：对于所有元素$h$,$g$，只需检查$g^{-1} \cdot h\in H$。

