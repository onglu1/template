# 数学
## 多项式  
### 结论  
1. 自然数幂之和$s(n) = \sum_{i = 0}^n i^k$是关于$n$的$k+1$次多项式  


### 拉格朗日插值法  
令拉格朗日函数  
$$l_i(x) = \prod_{j \not = i}\frac{x - x_j}{x_i-x_j}$$
注意到这个函数有一些性质：  
1. 次数为$n$  
2. 在$x=x_i$位置值为$1$,$x=x_j(j\not =i)$位置值为$0$  
于是可以凑出唯一的多项式表达式为：  
$$f(x) = \sum_{i=0}^{n}y_i\prod_{j\not = i}\frac{x - x_j}{x_i-x_j}$$  
如果要取模的话得求逆元，逆元先求好分母再一起求即可。  
```cpp
int interpolation(int *x, int *y, int n) {
    int f = 0;
    for(int i = 1; i <= n; i++) {
        int s1 = 1, s2 = 1;
        for(int j = 1; j <= n; j++) {
            if(i != j) {
                s1 = 1ll * s1 * (k - x[j] + mod) % mod;
                s2 = 1ll * s2 * (x[i] - x[j] + mod) % mod;
            }
        }
        f = (f + 1ll * y[i] * s1 % mod * inv(s2) % mod) % mod;
    }
    return f;
}

```
### FFT  
FFT的想法是把第$k$号位置变成$f(\omega _n ^k)$，注意到$\omega _n ^k = -\omega _n ^{k + n / 2}$，于是可以进行变换。  
**几条公式：** 
$$\omega _n ^n = 1$$
$$\omega _n ^k = \omega _{2n} ^{2k}$$  
$$\omega _{2n} ^ {k + n} = -\omega _{2n} ^k$$

蝴蝶变换：相邻的位置为二进制的reverse  
DFT变换公式($DFT(f)$为矩阵)：  
令
$$G(x) = a_0 + a_2x + a_4x^2 + \dots$$
$$H(x) = a_1 + a_3x + a_5x^3 + \dots$$
则有
$$f(x) = G(x^2) + x \times H(x^2)$$
$$DFT(f(\omega _n ^k)) = DFT(G(\omega _{n/2} ^k) + \omega _n ^k \times DFT(H(\omega _{n/2} ^k)))$$
$$DFT(f(\omega _n ^{k + n / 2})) = DFT(G(\omega _{n/2} ^k) - \omega _n ^k \times DFT(H(\omega _{n/2} ^k)))$$

$DFT(G(\omega _{n/2} ^k), DFT(H(\omega _{n/2} ^k)))$可递归计算  


```cpp
struct Complex {double x, y;};
Complex operator+(const Complex &a, const Complex &b) {return (Complex) {a.x + b.x, a.y + b.y};}
Complex operator-(const Complex &a, const Complex &b) {return (Complex) {a.x - b.x, a.y - b.y};}
Complex operator*(const Complex &a, const Complex &b) {return (Complex) {a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x};}
namespace Polynomial {
	const double Pi = acos(-1.0);
	int rev[N];
	void change(Complex *y, int n) {
		for(int i = 0; i < n; i++) {
			rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (n >> 1) : 0);
		}
		for(int i = 0; i < n; i++) 
			if(i < rev[i])
				swap(y[i], y[rev[i]]);
	}
	void FFT(Complex *A, int n, int type) {
		//type = 1 DFT 
		//type = -1 IDFT 
        //确保n是2的幂次
		change(A, n);
		for(int m = 1; m < n; m <<= 1) {
			Complex Wn = (Complex) {cos(Pi / m), type * sin(Pi / m)};
			for(int i = 0; i < n; i += 2 * m) {
				Complex w = (Complex) {1.0, 0};
				for(int j = 0; j < m; j++, w = w * Wn) {
					Complex x = A[i + j], y = w * A[i + j + m];
					A[i + j] = x + y;
					A[i + j + m] = x - y;
				} 
			}
		}
		if(type == -1) {
			for(int i = 0; i < n; i++)
				A[i].x = A[i].x / n;
		}
	}
	
}
//以下代码加在主函数内  
limit = 1;
while(limit <= n + m) limit <<= 1;
Polynomial :: FFT(A, limit, 1); 
Polynomial :: FFT(B, limit, 1);
for(int i = 0; i < limit; i++) A[i] = A[i] * B[i];
Polynomial :: FFT(A, limit, -1);
```

## 群论  
### 结论  
1. **子群检验法**:群$G$是群$H$的子群的充分必要条件：对于所有元素$h$,$g$，只需检查$g^{-1} \cdot h\in H$。

