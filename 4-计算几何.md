# 计算几何


## 结构体定义

```cpp
const double Pi = acos(-1.0);
const double eps = 1e-11;
struct line;
struct Point;
struct Point {
	double x, y;
	Point() : x(0), y(0) {}
	Point(double x, double y) : x(x), y(y) {}
	Point(const line &l);
};
struct line{
	Point s, t;
	line() {}
	line(const Point &s, const Point &t) : s(s), t(t) {}
};

struct circle{
	Point c;
	double r;
	circle() : c(Point(0,0)), r(0) {}
	circle(const Point &c, double r) : c(c), r(r) {}
    Point point(double a) {
        return Point(c.x + cos(a)*r, c.y + sin(a)*r);
    }
};
typedef Point Vector;
Point operator+(const Point &a, const Point &b) { return Point(a.x + b.x, a.y + b.y); }
Point operator-(const Point &a, const Point &b) { return Point(a.x - b.x, a.y - b.y); }
Point operator*(const Point &a, const double &c) { return Point(c * a.x, c * a.y); }
Point operator/(const Point &a, const double &c) { return Point(a.x / c, a.y / c); }
inline bool operator < (const Point &a, const Point &b) {
    return sgn(a.x - b.x) < 0 || (sgn(a.x - b.x) == 0 && sgn(a.y - b.y) < 0);
}
Point :: Point(const line &l) { *this = l.t - l.s; }
// 三态函数
int sgn(double x) {
    if(fabs(x) < eps) return 0;
    else return x < 0 ? -1 : 1;
}
bool operator == (const Point& a, const Point& b) { return !sgn(a.x - b.x) && !sgn(a.y - b.y); }
// 点积
double dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; }
// 叉积
double det(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; }
double cross(const Point& s, const Point& t, const Point& o = Point()) { return det(s - o, t - o); }

```
## 基本操作
```cpp
// 点到原点距离
double abs(const Point &a){ return sqrt(a.x * a.x + a.y * a.y); }
// 点旋转theta角度
Point rot(const Point &a, double theta){ return Point(a.x * cos(theta) - a.y * sin(theta), a.x * sin(theta) + a.y * cos(theta)); }
// 逆时针旋转90度
Point rotCCW90(const Point &a) { return Point(-a.y, a.x); }
// 顺时针旋转90度
Point rotCW90(const Point &a) { return Point(a.y, -a.x); }
// 点的幅角
double arg(const Point &a){
	double t = atan2(a.y, a.x);
	return t < 0 ? t + 2 * Pi:t;
}
```

## 线  
```cpp
// 是否平行
bool parallel(const line &a, const line &b) {
	return !sgn(det(a.t - a.s, b.t - b.s));
}
// 直线是否相等
bool l_eq(const line& a, const line& b) {
    return parallel(a, b) && parallel(line(a.s, b.t), line(b.s, a.t));
}
```
## 点与线  
```cpp
// 点是否在线段上，<= 包含端点
bool p_on_seg(const Point &p, const line &seg) {
	return !sgn(det(p - seg.s, p - seg.t)) && sgn(dot(p - seg.s, p - seg.t)) <= 0;
}
// 点到直线距离
double dist_to_line(const Point &p, const line &l) {
	return fabs(cross(l.s, l.t, p)) / abs(Point(l));
}
// 点到线段距离
double dist_to_seg(const Point &p, const line &l) {
    if (l.s == l.t) return abs(p - l.s);
    Vector vs = p - l.s, vt = p - l.t;
    if (sgn(dot(Point(l), vs)) < 0) return abs(vs);
    else if (sgn(dot(Point(l), vt)) > 0) return abs(vt);
    else return dist_to_line(p, l);
}
```
## 线与线  
```cpp
// 直线交点，需保证存在
Point l_intersection(const line& a, const line& b) {
    double s1 = det(Point(a), b.s - a.s), s2 = det(Point(a), b.t - a.s);
    return (b.s * s2 - b.t * s1) / (s2 - s1);
}
// 线段和直线是否有交   1 = 规范，2 = 不规范
int s_l_cross(const line &seg, const line &line) {
    int d1 = sgn(cross(line.s, line.t, seg.s));
    int d2 = sgn(cross(line.s, line.t, seg.t));
    if ((d1 ^ d2) == -2) return 1; // proper
    if (d1 == 0 || d2 == 0) return 2;
    return 0;
}
// 线段的交   1 = 规范，2 = 不规范
// 如果是不规范相交，p_on_seg函数要改成 <=
int s_cross(const line &a, const line &b, Point &p) {
    int d1 = sgn(cross(a.t, b.s, a.s)), d2 = sgn(cross(a.t, b.t, a.s));
    int d3 = sgn(cross(b.t, a.s, b.s)), d4 = sgn(cross(b.t, a.t, b.s));
    if ((d1 ^ d2) == -2 && (d3 ^ d4) == -2) { p = l_intersection(a, b); return 1; }
    if (!d1 && p_on_seg(b.s, a)) { p = b.s; return 2; }
    if (!d2 && p_on_seg(b.t, a)) { p = b.t; return 2; }
    if (!d3 && p_on_seg(a.s, b)) { p = a.s; return 2; }
    if (!d4 && p_on_seg(a.t, b)) { p = a.t; return 2; }
    return 0;
}
```
## 多边形  
```cpp
#define nxt(i) ((i + 1) % s.size())
typedef vector<Point> Polygon
// 多边形面积
double poly_area(const Polygon &s){
    double area = 0;
    for(int i = 1; i < s.size() - 1; i++)
        area += cross(s[i], s[i + 1], s[0]);
    return area / 2;
}
// 多边形是否为凸多边形
int is_convex(const Polygon &s) {
	int x = 1;
	int sg = 0;
	for(int i = 1; i < s.size(); i++) {
		if(!sg && sgn(det(s[i] - s[i - 1], s[nxt(i)] - s[i])) != 0) {
			sg = sgn(det(s[i] - s[i - 1], s[nxt(i)] - s[i]));
		}
		x &= (sgn(det(s[i] - s[i - 1], s[nxt(i)] - s[i])) == sg) ||
		(sgn(det(s[i] - s[i - 1], s[nxt(i)] - s[i])) == 0);
	}
	return x;
}
// 点是否在多边形中 0 = 在外部 1 = 在内部 -1 = 在边界上
int p_in_poly(Point p, const Polygon &s){
    int cnt = 0;
	for(int i = 0; i < s.size(); i++) {
        Point a = s[i], b = s[nxt(i)];
        if (p_on_seg(p, line(a, b))) return -1;
		//p在多边形边上
        if (sgn(a.y - b.y) <= 0) swap(a, b);
        if (sgn(p.y - a.y) > 0) continue;
        if (sgn(p.y - b.y) <= 0) continue;
		//一条边包含它较高的点，不包含较低的点
        cnt += sgn(cross(b, a, p)) > 0;
		//如果p在这条线段左边
    }
    return bool(cnt & 1);
}
```
### 凸包  
```cpp
Polygon Convex_hull(Polygon &s) {
	sort(s.begin(), s.end());
	Polygon ret(s.size() * 2);
	int sz = 0;
	for(int i = 0; i < s.size(); i++) {
		while(sz > 1 && sgn(cross(ret[sz - 1], s[i], ret[sz - 2])) < 0) sz--;
		ret[sz++] = s[i]; 
	}
	int k = sz;
	for(int i = s.size() - 2; i >= 0; i--) {
		while(sz > 1 && sgn(cross(ret[sz - 1], s[i], ret[sz - 2])) < 0) sz--;
		ret[sz++] = s[i]; 
	}
	ret.resize(sz - (s.size() > 1));
	return ret;
}
```
### 旋转卡壳  
用平行线夹多边形，根据两个向量的叉积判断支点变化
```cpp
double rotatingCalipers(const Polygon &s) {
	if(s.size() == 2) return abs(s[1] - s[0]);
	int i = 0, j = 0;
	for(int k = 0; k < s.size(); k++) {
		if(!(s[i] < s[k])) i = k;
		if(s[j] < s[k]) j = k;
	}
	double ans = 0;
	int si = i, sj = j;
	do{
		ans = max(ans, abs(s[i] - s[j]));
		if(sgn(det(s[nxt(i)] - s[i], s[nxt(j)] - s[j])) < 0)
			i = nxt(i);
		else j = nxt(j);
	} while(i != si || j != sj);
	return ans;
}
```

## 两圆的公切线
在res中存放的线上的两点分别是在c1,c2上的切点。
```cpp
int tangent(const circle &C1, const circle &C2, vector<line> &res){
	double d = abs(C1.c - C2.c);
	if(d < eps) return 0;

	int c=0;
	// 内公切线
	if(C1.r + C2.r < d - eps){
		double t = acos((C1.r + C2.r) / d);
		res.push_back(line(C1.c + rot(C1.r / d * (C2.c - C1.c), t), C2.c + rot(C2.r / d * (C1.c - C2.c), t)));
		res.push_back(line(C1.c + rot(C1.r / d * (C2.c - C1.c),-t), C2.c + rot(C2.r / d * (C1.c - C2.c),-t)));
		c += 2;
	} else if(C1.r + C2.r < d + eps){
		Point p = C1.c + C1.r / d * (C2.c - C1.c);
		res.push_back(line(p, p + rot(C2.c - C1.c, Pi / 2)));
		c++;
	}

	// 外公切线
	if(abs(C1.r - C2.r) < d - eps){
		double t1 = acos((C1.r - C2.r) / d), t2 = Pi - t1;
		res.push_back(line(C1.c + rot(C1.r / d * (C2.c - C1.c), t1), C2.c + rot(C2.r / d * (C1.c - C2.c),-t2)));
		res.push_back(line(C1.c + rot(C1.r / d * (C2.c - C1.c),-t1), C2.c + rot(C2.r / d * (C1.c - C2.c), t2)));
		c+=2;
	} else if(abs(C1.r - C2.r) < d + eps){
		Point p = C1.c + C1.r / d * (C2.c - C1.c);
		res.push_back(line(p, p + rot(C2.c - C1.c, Pi / 2)));
		c++;
	}

	return c;
}
```

## tips  

+ atan2(y, x)函数：点$(x,y)$到原点的方位角，值域在$(-\pi,\pi)$在一二象限为正，三四象限为负。

