# 计算几何


## 结构体定义

```cpp
const double Pi = acos(-1.0);
const double eps = 1e-11;
struct line;
struct Point;
struct Point {
	double x, y;
	Point() : x(0), y(0) {}
	Point(double x, double y) : x(x), y(y) {}
	Point(const line &l);
};
struct line{
	Point a, b;
	line() {}
	line(const Point &a,const Point &b) : a(a), b(b) {}
};

struct circle{
	Point c;
	double r;
	circle() : c(Point(0,0)), r(0) {}
	circle(const Point &c, double r) : c(c), r(r) {}
    Point point(double a) {
        return Point(c.x + cos(a)*r, c.y + sin(a)*r);
    }
};
typedef Point Vector;
Point operator+(const Point &a, const Point &b) { return Point(a.x + b.x, a.y + b.y); }
Point operator-(const Point &a, const Point &b) { return Point(a.x - b.x, a.y - b.y); }
Point operator*(const Point &a, const double &c) { return Point(c * a.x, c * a.y); }
Point operator/(const Point &a, const double &c) { return Point(a.x / c, a.y / c); }
Point :: Point(const line &l) { *this = l.b - l.a; }
//三态函数
int sgn(double x) {
    if(fabs(x) < eps) return 0;
    else return x < 0 ? -1 : 1;
}
bool operator == (const Point& a, const Point& b) { return !sgn(a.x - b.x) && !sgn(a.y - b.y); }
```
## 基本操作
```cpp
//点到原点距离
double abs(const Point &a){ return sqrt(a.x * a.x + a.y * a.y); }
//点旋转theta角度
Point rot(const Point &a, double theta){ return Point(a.x * cos(theta) - a.y * sin(theta), a.x * sin(theta) + a.y * cos(theta)); }
//逆时针旋转90度
Point rotCCW90(const Point &a) { return Point(-a.y, a.x); }
//顺时针旋转90度
Point rotCW90(const Point &a) { return Point(a.y, -a.x); }
//点的幅角
double arg(const Point &a){
	double t = atan2(a.y, a.x);
	return t < 0 ? t + 2 * Pi:t;
}
//点积
double dot(const Vector& a, const Vector& b) { return a.x * b.x + a.y * b.y; }
//叉积
double det(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; }
double cross(const Point& s, const Point& t, const Point& o = Point()) { return det(s - o, t - o); }
```

## 线  
```cpp
//是否平行
bool parallel(const line &a, const line &b) {
	return !sgn(det(a.b - a.a, b.b - b.a));
}
//直线是否相等
bool l_eq(const line& a, const line& b) {
    return parallel(a, b) && parallel(line(a.a, b.b), line(b.a, a.b));
}
```
## 点与线  
```cpp
//点是否在线段上，<= 包含端点
bool p_on_seg(const Point &p, const line &seg) {
	return !sgn(det(p - seg.a, p - seg.b)) && sgn(dot(p - seg.a, p - seg.b)) < 0;
}
//点到直线距离
double dist_to_line(const Point &p, const line &l) {
	return fabs(cross(l.a, l.b, p)) / abs(Point(l));
}
// 点到线段距离
double dist_to_seg(const Point &p, const line &l) {
    if (l.a == l.b) return abs(p - l.a);
    Vector vs = p - l.a, vt = p - l.b;
    if (sgn(dot(Point(l), vs)) < 0) return abs(vs);
    else if (sgn(dot(Point(l), vt)) > 0) return abs(vt);
    else return dist_to_line(p, l);
}
```
## 线与线  
```cpp
//直线交点，需保证存在
Point l_intersection(Point P, Vector v, Point Q, Vector w){
    Vector u = P - Q;
    double t = det(w, u) / det(v, w);
    return P + v * t;
}

```
## 多边形  
```cpp
#define nxt(i) ((i + 1) % s.size())
typedef vector<Point> Polygon
//多边形面积
double poly_area(const Polygon &s){
    double area = 0;
    for(int i = 1; i < s.size() - 1; i++)
        area += cross(s[i], s[i + 1], s[0]);
    return area / 2;
}
// 点是否在多边形中 0 = 在外部 1 = 在内部 -1 = 在边界上
int p_in_poly(Point p, const Polygon &s){
    int cnt = 0;
	for(int i = 0; i < s.size(); i++) {
        Point a = s[i], b = s[nxt(i)];
        if (p_on_seg(p, line(a, b))) return -1;
		//p在多边形边上
        if (sgn(a.y - b.y) <= 0) swap(a, b);
        if (sgn(p.y - a.y) > 0) continue;
        if (sgn(p.y - b.y) <= 0) continue;
		//一条边包含它较低的点，不包含较高的点
        cnt += sgn(cross(b, a, p)) > 0;
		//如果p在这条线段左边
    }
    return bool(cnt & 1);
}
```

## 两圆的公切线
在res中存放的线上的两点分别是在c1,c2上的切点。
```cpp
int tangent(const circle &C1, const circle &C2, vector<line> &res){
	double d = abs(C1.c - C2.c);
	if(d < eps) return 0;

	int c=0;
	// 内公切线
	if(C1.r + C2.r < d - eps){
		double t = acos((C1.r + C2.r) / d);
		res.push_back(line(C1.c + rot(C1.r / d * (C2.c - C1.c), t), C2.c + rot(C2.r / d * (C1.c - C2.c), t)));
		res.push_back(line(C1.c + rot(C1.r / d * (C2.c - C1.c),-t), C2.c + rot(C2.r / d * (C1.c - C2.c),-t)));
		c += 2;
	} else if(C1.r + C2.r < d + eps){
		Point p = C1.c + C1.r / d * (C2.c - C1.c);
		res.push_back(line(p, p + rot(C2.c - C1.c, Pi / 2)));
		c++;
	}

	// 外公切线
	if(abs(C1.r - C2.r) < d - eps){
		double t1 = acos((C1.r - C2.r) / d), t2 = Pi - t1;
		res.push_back(line(C1.c + rot(C1.r / d * (C2.c - C1.c), t1), C2.c + rot(C2.r / d * (C1.c - C2.c),-t2)));
		res.push_back(line(C1.c + rot(C1.r / d * (C2.c - C1.c),-t1), C2.c + rot(C2.r / d * (C1.c - C2.c), t2)));
		c+=2;
	} else if(abs(C1.r - C2.r) < d + eps){
		Point p = C1.c + C1.r / d * (C2.c - C1.c);
		res.push_back(line(p, p + rot(C2.c - C1.c, Pi / 2)));
		c++;
	}

	return c;
}
```

## tips  

+ atan2(y, x)函数：点$(x,y)$到原点的方位角，值域在$(-\pi,\pi)$在一二象限为正，三四象限为负。

